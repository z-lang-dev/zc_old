## 会话

## 需求

程序的内存问题，有一大类是因为指针可以自由传递，从分配的地方散布到程序各处，从而没有办法跟踪它的生命周期。
这样的结果要不就是完全忘记了释放，导致内存泄漏；要不就是释放掉了之后又在别的地方访问，导致了悬指针问题；要不就是在不同地方多次释放，导致重复释放问题。

这类问题的解决思路，答题有两类：

- 增加消耗，自动管理内存。引用计数和垃圾回收都属于这个思路。这两种方式下，指针对应的内存够都由系统管理起来。
    - 引用计数：用胖指针替代普通指针，每次访问都要进行引用数据的记录，以便于跟踪引用关系，从而能够安全并及时地释放。
    - 垃圾回收：所有的指针都另外统一存储管理，定期扫描全局指针，重建引用关系网络，找到不再被引用的内存，进行回收。

- 增加限制，让指针只能在安全的地方使用和释放。
    - 例如，C++的`unique_ptr`，就比引用计数的`shared_ptr`限制更多；同时只能有一个所有人，需要`move`语法去转移所有权。这样的限制就能从引用计数中解放出来，达到安全使用的目标。但这种限制也导致很多地方没法用它。
    - Rust的所有权机制、借用机制和生命周期机制，总体来说都是编译期增加的限制，来保证指针的生命周期符合它设置的规律，能够安全释放。但Rust的机制比较复杂，对程序员有更高的心智负担。

## 设计

Z语言里会话是第一级的概念。和类型、函数、变量等类似。

如果我们把type类型看做是空间上的组合的话，那么会话就是时间上的组合。

会话是一种特殊的类型，它有自己的成员，但它更关注的是各个成员变量的生命周期。

会话的关键字是`ss`（即`session`的简写）。我们可以这样定义一个会话：

```z
ss MySession {
    let a = 1 // 会话级别的标量，会在会话结束时销毁
    mut b [int] // 这个数组也是会话级别的数组，会在会话结束时销毁

    // 会话有对应的方法，其中，init()、bye()是特殊的方法，将会在会话开始和结束时自动调用
    fn init {
        b.push(1, 2, 3)
    }

    fn bye {
        println("bye")
        // 这里不需要手动释放b，因为它是会话级别的变量，会在会话结束时自动释放
    }

}

let GlobalMap = {}

fn main() {
    // 会话和协程绑定，每个协程里，每种类型的会话只能有一个实例，因此可以用单例模式来访问
    MySession.start()
    let b = &MySession.b
    b.push(4, 5, 6)
    println(ss.b)

    // 会话结束，内部的变量会被自动释放
    MySession.stop()

    // Error! Session stopped!
    let b = &MySession.b
}
```


